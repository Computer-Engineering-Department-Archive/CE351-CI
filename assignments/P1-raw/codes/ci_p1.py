# -*- coding: utf-8 -*-
"""CI_P1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14wNHlrpc4RcFnR5wiucBgmqtXMFj1NXV

# Mounting Google Drive
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Imports"""

import numpy as np
import matplotlib.pyplot as plt
import math, random, os

"""# Change Directory"""

dataset_dir = '/content/drive/MyDrive/Colab Datasets/MNIST/'
os.chdir(dataset_dir)

"""# Reading The Train & Test Sets"""

train_images_file = open('train-images.idx3-ubyte', 'rb')
train_images_file.seek(4)
num_of_train_images = int.from_bytes(train_images_file.read(4), 'big')
train_images_file.seek(16)

train_labels_file = open('train-labels.idx1-ubyte', 'rb')
train_labels_file.seek(8)

train_set = []
for n in range(num_of_train_images):
  image = np.zeros((784, 1))
  for i in range(784):
    image[i, 0] = int.from_bytes(train_images_file.read(1), 'big') / 256
  
  label_value = int.from_bytes(train_labels_file.read(1), 'big')
  label = np.zeros((10, 1))
  label[label_value, 0] = 1
  
  train_set.append((image, label))

test_images_file = open('t10k-images.idx3-ubyte', 'rb')
test_images_file.seek(4)

test_labels_file = open('t10k-labels.idx1-ubyte', 'rb')
test_labels_file.seek(8)

num_of_test_images = int.from_bytes(test_images_file.read(4), 'big')
test_images_file.seek(16)

test_set = []
for n in range(num_of_test_images):
  image = np.zeros((784, 1))
  for i in range(784):
    image[i] = int.from_bytes(test_images_file.read(1), 'big') / 256
  
  label_value = int.from_bytes(test_labels_file.read(1), 'big')
  label = np.zeros((10, 1))
  label[label_value, 0] = 1
  
  test_set.append((image, label))

def show_image(img):
  image = np.zeros((28, 28))
  for i in range(28):
    for j in range(28):
      image[i, j] = img[i * 28 + j]
  plt.imshow(image, 'gray')

show_image(test_set[100][0])

"""# Weights & Biases Initialization"""

def init(c, r):
  weight = np.random.normal(0, 2/r, size=(c, r))
  bias = np.zeros((c, 1))

  return weight, bias

def pprint(weight, bias):
  np.set_printoptions(suppress=True, formatter={'float': '{: 0.3f}'.format})
  print('='*80)

  print(f'[#] Weight\n{weight.shape}\n{weight}\n')
  print(f'[#] Biases\n{bias.shape}\n{bias}\n')

  print('='*80)

pprint(np.random.normal(0, 1, size=(10, 10)), np.zeros((10, 1)))

# layer 1
W1, b1=init(16, 28*28)
# layer 2
W2, b2=init(16, 16)
# layer 3
W3, b3=init(10, 16)

"""# Plotting Weights and Biases"""

pprint(W1, b1)
pprint(W2, b2)
pprint(W3, b3)

"""# Activation & Cost Function"""

def sigmoid(x):
  return 1 / (1 + np.exp(-x))

def d_sigmoid(x):
  s = sigmoid(x) 
  return s * (1 - s)

def cost(exp, pred):
  cost = 0
  for i in range(10):
    cost += (exp[i] - pred[i]) ** 2
  return cost

"""# Hyperparameters"""

batch_size = 50
epochs = 5
alpha = 1

"""# Gradients"""

def gradient(c, r):
  return np.zeros((c, r))

def get_gradients():
  return gradient(16, 28*28), gradient(16, 1), gradient(16, 16), gradient(16, 1), gradient(10, 16), gradient(10, 1)

"""# Initialization"""

def get_neurons(image_set, image_index):  
  return image_set[image_index][0], np.zeros((1, 16)), np.zeros((1, 16)), np.zeros((1, 10))

def get_sigmoids():
  return np.zeros((16, 1)), np.zeros((16, 1)), np.zeros((10, 1))

"""# Feed Forward & Back Propagation"""

def feed_forward():
  global a0, a1, a2, a3
  global z1, z2, z3
  global y
  global W1, b1, W2, b2, W3, b3

  # Layer 1  
  z1 = W1 @ a0 + b1
  a1 = sigmoid(z1)
  # Layer 2
  z2 = W2 @ a1 + b2
  a2 = sigmoid(z2)
  # Layer 3
  z3 = W3 @ a2 + b3
  a3 = sigmoid(z3)

def backpropagation():
  global a0, a1, a2, a3
  global z1, z2, z3
  global y
  global W1, b1, W2, b2, W3, b3
  global grad_W1, grad_b1, grad_W2, grad_b2, grad_W3, grad_b3

  # Layer 3
  grad_W3 += (2 * d_sigmoid(z3) * (a3 - y)) @ (np.transpose(a2))
  grad_b3 += 2 * d_sigmoid(z3) * (a3 - y)
  grad_a2 = np.transpose(W3) @ (2 * d_sigmoid(z3) * (a3 - y))
  # Layer 2
  grad_W2 += (d_sigmoid(z2) * grad_a2) @ (np.transpose(a1))
  grad_b2 += d_sigmoid(z2) * grad_a2
  grad_a1 = np.transpose(W2) @ (d_sigmoid(z2) * grad_a2)
  # Layer 1
  grad_W1 += (d_sigmoid(z1) * grad_a1) @ (np.transpose(a0))
  grad_b1 += d_sigmoid(z1) * grad_a1

"""# Updating Weights & Biases"""

def update():
  global W3, b3, W2, b2, W1, b1

  # Weight and Bias 3
  W3 = W3 - alpha * (grad_W3 / batch_size)
  b3 = b3 - alpha * (grad_b3 / batch_size)
  # Weight and Bias 2
  W2 = W2 - alpha * (grad_W2 / batch_size)
  b2 = b2 - alpha * (grad_b2 / batch_size)
  # Weight and Bias 1
  W1 = W1 - alpha * (grad_W1 / batch_size)
  b1 = b1 - alpha * (grad_b1 / batch_size)

"""# Training"""

num_samples = len(train_set)

avg_costs = []
accuracy_list = []
for epoch in range(epochs):

  print('epoch number:', epoch)
  # shuffling the train set
  random.shuffle(train_set)

  sum_cost = 0
  true_positive = 0
  num_of_images = 0
  for batch_number in range(num_samples // batch_size):
    grad_W1, grad_b1, grad_W2, grad_b2, grad_W3, grad_b3 = get_gradients()
      
    for image_index in range(batch_number * batch_size, (batch_number + 1) * batch_size):
      a0, a1, a2, a3 = get_neurons(train_set, image_index)
      z1, z2, z3 = get_sigmoids()
      y = train_set[image_index][1]

      feed_forward()

      sum_cost += cost(a3, y)

      backpropagation()

      if np.argmax(a3) == np.argmax(y):
        true_positive += 1
      num_of_images += 1
  
    # updating weights and biases
    update()

  # recording average cost in the current step
  avg_costs.append(sum_cost / num_samples)

  # print epochs info
  accuracy = true_positive/num_of_images
  accuracy_list.append(accuracy)
  print(f' - [*] For {epoch}th epoch: train accuracy: {true_positive}/{num_of_images} = {accuracy*100:.2f}')

"""# Average Cost"""

plt.plot(avg_costs)
plt.show()

"""# Accuracy Plot"""

plt.plot(accuracy_list)
plt.show()

"""# Evaluating The Network"""

def evaluate(image_set):
  global a0, a1, a2, a3
  global y_actual, y_pred
  global true_positive

  for j in range(10):
    if (image_set[i][1])[j] == 1:
      y_actual = j
      break
          
  for j in range(1, 10):
    if a3[j, 0] > a3[y_pred, 0]:
      y_pred = j

  if y_pred == y_actual:
    true_positive += 1

true_positive = 0

for i in range(num_of_train_images):
  a0, a1, a2, a3 = get_neurons(train_set, i)
  z1, z2, z3 = get_sigmoids()
  y = train_set[i][1]

  feed_forward()
  
  y_actual = -1
  y_pred = 0
  evaluate(train_set)
    
succes_rate = true_positive / num_of_train_images
print(f'{true_positive}, {num_of_train_images}')
print(f'Train Accuracy = {succes_rate*100:.2f}%')

true_positive = 0

for i in range(num_of_test_images):
  a0, a1, a2, a3 = get_neurons(test_set, i)
  z1, z2, z3 = get_sigmoids()

  feed_forward()
    
  y_actual = -1
  y_pred = 0
  evaluate(test_set)
    
succes_rate = true_positive / num_of_test_images
print(f'{true_positive}, {num_of_test_images}')
print(f'Test Accuracy = {succes_rate*100:.2f}%')